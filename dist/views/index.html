<!DOCTYPE html>
<html lang="en">
<head>
<title>Home Page</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://moment.github.io/luxon/global/luxon.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@0.1.1"></script>
<script src="https://www.chartjs.org/chartjs-chart-financial/chartjs-chart-financial.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.6/moment.min.js"></script>
<script src="https://moment.github.io/luxon/global/luxon.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.25/moment-timezone-with-data.js"></script>


<script src="https://d3js.org/d3.v4.min.js"></script>	

<script src="https://unpkg.com/lodash@4.17.4"></script>
<script src="https://unpkg.com/d3-scale-chromatic@1.1.1"></script>

<!-- include polyfills for custom event, Symbol and Custom Elements -->
<script src="//unpkg.com/babel-polyfill@6.26.0/dist/polyfill.js"></script>
<script src="//unpkg.com/custom-event-polyfill@0.3.0/custom-event-polyfill.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/document-register-element/1.8.0/document-register-element.js"></script>

<!-- use babel so that we can use arrow functions and other goodness in this block! -->
<script src="//unpkg.com/babel-standalone@6/babel.min.js"></script>

<script src="//unpkg.com/d3@5.5.0"></script>
<script src="//unpkg.com/d3fc@14.0.41"></script>

<style>

    g.profile g.multi {
      opacity: 0.8;
    }
    g.profile g.multi:hover {
      opacity: 1.0;
    }



    .loader {
      border: 10px solid #f3f3f3;
      border-radius: 50%;
      border-top: 10px solid #3498db;
      width: 50px;
      height: 50px;
      -webkit-animation: spin 2s linear infinite; /* Safari */
      animation: spin 2s linear infinite;
      position: fixed;
      left: 45%;
      top: 45%;
      transform: translate(-50%, -50%);
    }

    * {
      font-family: Sans-Serif;
    }

    h1 {
      font-size: 1.5em;
    }

    h2 {
      font-size: 1.25em;
    }

    .chartjs-render-monitor {
      animation: chartjs-render-animation 1ms;
  }

  /* Safari */
  @-webkit-keyframes spin {
    0% { -webkit-transform: rotate(0deg); }
    100% { -webkit-transform: rotate(360deg); }
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }


  .upGreenArrow{
   width: 0;
   height: 0;
   border-style: solid;
   border-width: 0 4.5px 12px 4.5px;
   border-color: transparent transparent #00ff00 transparent;
}
  
.downRedArrow{
   width: 0;
   height: 0;
   border-style: solid;
   border-width: 12px 4.5px 0 4.5px;
   border-color: #ff0000 transparent transparent transparent;
}

.upArrow{
  position: relative;
  top: -15px;
  left: -10px;
  width:0;
  height:0;
  border: 6px solid transparent;
  border-bottom-color: #00ff00;
}
.upArrow:after{
  position: absolute;
  content: '';
  top: 20px;
  left: -3px;
  width: 6px;
  height: 10px;
  background: #00ff00;
}

.downArrow{
  position: relative;
  top: 18px;
  left: -10px;
  width: 0;
  height: 0;
  border: 6px solid transparent;
  border-top-color: #ff0000;
}
.downArrow:after{
  position: absolute;
  content: '';
  top: -15px;
  left: -3px;
  width: 6px;
  height: 10px;
  background: #ff0000;
}


/* d3 candle stick start */

.axis path,
.axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: 'Open Sans', sans-serif;
    font-size: 11px;
    fill: black;
}

/* d3 candle stick end */

body {
  background-color: white;
}


</style>

<script type="text/javascript">
$(document).ready( function () {
        var server = window.location.port ? window.location.protocol +"//"+window.location.hostname +":"+window.location.port: window.location.protocol +"//"+window.location.hostname;
        $('#userTxt').text(localStorage.getItem('user'));
        var interval = "15MINUTE";
        var symbol = 'sbin';
        var chunkSize = 0;

        $( "#intervalDropDown" ).change(function() {
          interval = $("#intervalDropDown").val();

          if(interval == "5MINUTE"){
            chunkSize = 75;
          }
          if(interval == "10MINUTE"){
            chunkSize = 36;
          }
          else if(interval == "15MINUTE"){
            chunkSize = 25;
          }
          else if(interval == "30MINUTE"){
            chunkSize = 13;
          }
          else if(interval == "60MINUTE"){
            chunkSize = 7;
          }
          else{
            chunkSize = 5;
          }
          
          loadSymbolData(symbol,interval);
        });

        $( "#symbolTxt" ).change(function() {
          symbol = $("#symbolTxt").val();
          loadSymbolData(symbol,interval);
          $( "#symbolTxt" ).val("");
        });

        $(".loader").show();
        $("#chartDiv").empty();
        $.ajax({
        type: "get",
        url: server + '/getIndices',success: function(data){
              helpers.buildDropdown(
                  data,
                  $('#symbolDropdown'),
                  'Select an option'
              );
              $(".loader").hide();
              symbol = 'NIFTY_50';
              interval = "15MINUTE";
              
              
              loadSymbolData(symbol,interval);
          }
        });

        var helpers = {
          buildDropdown: function(result, dropdown, emptyMessage){
              dropdown.html('');
              dropdown.append('<option value="">' + emptyMessage + '</option>');
              if(result != ''){
                  $.each(result, function(k, v) {
                      dropdown.append('<option value="' + v + '">' + v + '</option>');
                  });
              }
          }
        }

        var ctx;

        function loadSymbolData(symbolName,interval){
          $( "#symbol_txt" ).html(symbolName);
          $(".loader").show();
          $.get({
            url: server+'/getStockIndicators/'+symbolName+"/"+interval,
            success: function(response){
           
                var dataSet = response.filter(function (el) {
                  return (el != null && el.CLOSE != null && el.CLOSE != undefined && el.CLOSE != "");
                });
                $(".loader").hide();       
                dataSet.filter((obj) => obj );
              
              
                  $("#chartDiv").empty();
                var canvas = document.createElement('canvas');
                canvas.id  = "myChart";
                $( "#chartDiv" ).append(canvas);
                ctx = document.getElementById("myChart").getContext('2d');
                ctx.canvas.width = 1100;
                ctx.canvas.height = 650;

                var now = new Date(Number(dataSet[0].LASTTRADETIME));
                var india = moment.tz(now, "Asia/Kolkata");
                india.format(); 
                var start_date =india.date()+"-"+(india.month())+"-"+india.year() +"  "+india.hour()+":"+india.minute();
                $("#date_txt").html(start_date);

                
                var stockData = dataSet.map(obj =>{ 
                var rObj = obj;//{};

                  var india = moment.tz(new Date(Number(obj.LASTTRADETIME)), "Asia/Kolkata");
                  india.format(); 

                  var d = new Date();
                  d.setDate(india.date());
                  d.setMonth(india.month());
                  d.setFullYear(india.year());
                  d.setHours(india.hour());
                  d.setMinutes(india.minute());
                  rObj.LASTTRADETIME= d;//.getTime();
                  rObj.date= d;//.getTime();
                 rObj.t= d.getTime();
                  rObj.o= Number(obj.OPEN);
                  rObj.h= Number(obj.HIGH);
                  rObj.l= Number(obj.LOW);
                  rObj.c= Number(obj.CLOSE);
                  return rObj;
                }); 
                
               
                stockData.reverse();
                //drawCandleStick(stockData);
                marketProfileChart(stockData);
               
                var chart = new Chart(ctx, 
                {
                  type: 'candlestick',
                  data: {
                    datasets: [{
                      label: symbolName,
                      data: stockData
                    }]
                  },
                  options: {
                       legend: {
                        display: false,
                   }
                  }
                });    
                var dataset = chart.config.data.datasets[0];
                dataset.color = {
                  up: '#01ff01',
                  down: '#fe0000',
                  unchanged: '#999',
                };
                

                chart.update();
	            }
      });  



      

      function marketProfileChart(stockData){
           
            
            const createMarketProfile = (data, priceBuckets) => {
                // find the price bucket size
                const priceStep = priceBuckets[1] - priceBuckets[0];

                // determine whether a datapoint is within a bucket
                const inBucket = (datum, priceBucket) =>
                  datum.LOW < priceBucket && datum.HIGH > (priceBucket - priceStep);

                // the volume contribution for this range
                const volumeInBucket = (datum, priceBucket) =>
                  inBucket(datum, priceBucket) ? datum.volume / Math.ceil((datum.HIGH - datum.LOW) / priceStep) : 0;

                // map each point in our time series, to construct the market profile
                const marketProfile = data.map(
                                  (datum, index) => priceBuckets.map(priceBucket => {
                                    // determine how many points to the left are also within this time bucket
                                    const base = d3.sum(data.slice(0, index)
                                                .map(d => volumeInBucket(d, priceBucket)));
                                    return {
                                        base,
                                        value: base + volumeInBucket(datum, priceBucket),
                                        price: priceBucket
                                        };
                                  })
            );

            // similar to d3-stack - cache the underlying data
            marketProfile.data = data;
            return marketProfile;
            };

            const seriesMarketProfile = () => {
            let xScale, yScale;
            let bandwidth = 20;
            const join = fc.dataJoin('g', 'profile');

            const barSeries = fc.autoBandwidth(fc.seriesSvgBar())
                .orient('horizontal')
                .crossValue(d => d.price)
                .mainValue(d => d.value)
                .baseValue(d => d.base);

            const colorScale = d3.scaleSequential(d3.interpolateSpectral);

            const repeatSeries = fc.seriesSvgRepeat()
                .series(barSeries)
                .orient('horizontal')
                .decorate((selection) => {
                  selection.enter()
                  .each((data, index, group) => {
                    d3.select(group[index])
                      .selectAll('g.bar')
                      .attr('fill', () => colorScale(index/stockData.length * 4));
                  });
                });

            const series = (selection) => {
              selection.each((data, index, group) => {

                  const xDomain = d3.extent(_.flattenDeep(data).map(d => d.value));
                  colorScale.domain([0, data.length]);

                  join(d3.select(group[index]), data)
                  .each((marketProfile, index, group) => {

                      // create a composite scale that applies the required offset
                      const leftEdge = xScale(marketProfile.data[0].LASTTRADETIME);
                      const offset = d3.scaleLinear()
                          .domain(xDomain)
                          .range([leftEdge, leftEdge + bandwidth]);

                      repeatSeries.yScale(yScale)
                          .xScale(offset);

                      d3.select(group[index])
                        .call(repeatSeries);
                      });
                  })
                };

            series.xScale = (...args) => {
              if (!args.length) {
                return xScale;
              }
              xScale = args[0];
                return series;
              };

              series.bandwidth = (...args) => {
                if (!args.length) {
                return bandwidth;
              }
              bandwidth = args[0];
                return series;
              };

              series.yScale = (...args) => {
              if (!args.length) {
              return yScale;
              }
              yScale = args[0];
              return series;
              };

              return series;
            }

            const pointOfControl = (marketProfile) => 
            _.maxBy(_.flatten(marketProfile), d => d.value).price;


            const timeSeries = stockData;


            // determine the price range
            const extent = fc.extentLinear()
            .accessors([d => d.HIGH, d => d.LOW]);
            const priceRange = extent(timeSeries);

            // use a d3 scale to create a set of price buckets
            const priceScale = d3.scaleLinear()
            .domain(priceRange);
            const priceBuckets = priceScale.ticks(40);

            const series = _.chunk(timeSeries, chunkSize)
            .map((data) => createMarketProfile(data, priceBuckets));

            const marketProfileSeries = fc.autoBandwidth(seriesMarketProfile());

            const pocSeries = fc.autoBandwidth(fc.seriesSvgErrorBar())
              .crossValue(d => d.LASTTRADETIME)
              .LOWValue(d => d.value)
              .HIGHValue(d => d.value)
              .align('left');

            const multiSeries = fc.seriesSvgMulti()
              .series([marketProfileSeries, pocSeries])
              .mapping((data, index, series) => {
              switch(series[index]) {
                case pocSeries:
                  return data.map(d => ({
                    date: d.data[0].LASTTRADETIME,
                    value: pointOfControl(d)
                  }));
                case marketProfileSeries:
                 return data;
                }
              });

            const xExtent = fc.extentDate()
              .accessors([d => d.data[0].LASTTRADETIME]);

            const profileChart = fc.chartSvgCartesian(
                d3.scaleBand(),
                d3.scaleBand()
                )
                .xDomain(series.map(s => s.data[0].LASTTRADETIME))
                .yDomain(priceBuckets)
                .yTickValues(priceBuckets.filter((d, i) => i % 10 == 0))
                .xTickFormat(d3.timeFormat('%Y-%m-%d'))// %H:%M
                .yOrient('left')
                .xPadding(0.3)
                .plotArea(multiSeries);

            const margin = {top: 15, right: 5, bottom: 50, left: 5},
            w = 1000 - margin.left - margin.right,
            h = 625 - margin.top - margin.bottom;

            var svg = d3.select("#marketChart")
            .attr("width", w + margin.left + margin.right)
            .attr("height", h + margin.top + margin.bottom)
            .append("g");
            // .attr("transform", "translate(" +margin.left+ "," +margin.top+ ")");

            d3.select('#marketChart')
            .datum(series)
            .call(profileChart);
      }


      function drawChart(prices) {
            //$("#container").empty()
            const months = {0 : 'Jan', 1 : 'Feb', 2 : 'Mar', 3 : 'Apr', 4 : 'May', 5 : 'Jun', 6 : 'Jul', 7 : 'Aug', 8 : 'Sep', 9 : 'Oct', 10 : 'Nov', 11 : 'Dec'}
            var dateFormat = d3.timeParse("%Y-%m-%d");
            
            const margin = {top: 15, right: 5, bottom: 50, left: 5},
            w =1000 - margin.left - margin.right,
            h = 625 - margin.top - margin.bottom;

            var svg = d3.select("#container")
                  .attr("width", w + margin.left + margin.right)
                  .attr("height", h + margin.top + margin.bottom)
                  .append("g");
                  //.attr("transform", "translate(" +margin.left+ "," +margin.top+ ")");

            let dates = _.map(prices, 'Date');

            var xmin = d3.min(prices.map(r => r.Date.getTime()));
            var xmax = d3.max(prices.map(r => r.Date.getTime()));
            var xScale = d3.scaleLinear().domain([-1, dates.length])
                  .range([0, w])
            var xDateScale = d3.scaleQuantize().domain([0, dates.length]).range(dates)
            let xBand = d3.scaleBand().domain(d3.range(-1, dates.length)).range([0, w]).padding(0.3)
            var xAxis = d3.axisBottom()
                        .scale(xScale)
                        .tickFormat(function(d1) {
                          if(d1 < dates.length){
                              d = dates[d1]
                              //hours = d.getHours()
                              //minutes = (d.getMinutes()<10?'0':'') + d.getMinutes() 
                            // amPM = hours < 13 ? 'am' : 'pm'
                              return d.getDate() + ' ' + months[d.getMonth()] + ' ' + d.getFullYear()//hours + ':' + minutes + amPM + ' ' + 
                            }
                        
                 });

            svg.append("rect")
                .attr("id","rect")
                .attr("width", w)
                .attr("height", h)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr("clip-path", "url(#clip)")

            var gX = svg.append("g")
                .attr("class", "axis x-axis") //Assign "axis" class
                .attr("transform", "translate(0," + h + ")")
                .call(xAxis)

            gX.selectAll(".tick text")
            .call(wrap, xBand.bandwidth())

            var ymin = d3.min(prices.map(r => r.LOW));
            var ymax = d3.max(prices.map(r => r.HIGH));
            var yScale = d3.scaleLinear().domain([ymin, ymax]).range([h, 0]).nice();
            var yAxis = d3.axisLeft()
                  .scale(yScale)

            var gY = svg.append("g")
                .attr("class", "axis y-axis")
                .call(yAxis);

            var chartBody = svg.append("g")
                .attr("class", "chartBody")
                .attr("clip-path", "url(#clip)");

            // draw rectangles
            let candles = chartBody.selectAll(".candle")
              .data(prices)
              .enter()
              .append("rect")
              .attr('x', (d, i) => xScale(i) - xBand.bandwidth())
              .attr("class", "candle")
              .attr('y', d => yScale(Math.max(d.OPEN, d.CLOSE)))
              .attr('width', xBand.bandwidth())
              .attr('height', d => (d.OPEN === d.CLOSE) ? 1 : yScale(Math.min(d.OPEN, d.CLOSE))-yScale(Math.max(d.OPEN, d.CLOSE)))
              .attr("fill", d => (d.OPEN === d.CLOSE) ? "silver" : (d.OPEN > d.CLOSE) ? "red" : "green")

            // draw high and low
            let stems = chartBody.selectAll("g.line")
              .data(prices)
              .enter()
              .append("line")
              .attr("class", "stem")
              .attr("x1", (d, i) => xScale(i) - xBand.bandwidth()/2)
              .attr("x2", (d, i) => xScale(i) - xBand.bandwidth()/2)
              .attr("y1", d => yScale(d.HIGH))
              .attr("y2", d => yScale(d.LOW))
              .attr("stroke", d => (d.OPEN === d.CLOSE) ? "white" : (d.OPEN > d.CLOSE) ? "red" : "green");

            svg.append("defs")
              .append("clipPath")
              .attr("id", "clip")
              .append("rect")
              .attr("width", w)
              .attr("height", h)

            const extent = [[0, 0], [w, h]];

           
           
              var t = d3.event.transform;
              let xScaleZ = t.rescaleX(xScale);
              clearTimeout(resizeTimer)
              resizeTimer = setTimeout(function() {

              var xmin = new Date(xDateScale(Math.floor(xScaleZ.domain()[0])))
                xmax = new Date(xDateScale(Math.floor(xScaleZ.domain()[1])))
                filtered = _.filter(prices, d => ((d.Date >= xmin) && (d.Date <= xmax)))
                minP = +d3.min(filtered, d => d.LOW)
                maxP = +d3.max(filtered, d => d.HIGH)
                buffer = Math.floor((maxP - minP) * 0.1)

              yScale.domain([minP - buffer, maxP + buffer])
              candles.transition()
                    .duration(800)
                    .attr("y", (d) => yScale(Math.max(d.OPEN, d.CLOSE)))
                    .attr("height",  d => (d.OPEN === d.CLOSE) ? 1 : yScale(Math.min(d.OPEN, d.CLOSE))-yScale(Math.max(d.OPEN, d.CLOSE)));
                    
              stems.transition().duration(800)
                  .attr("y1", (d) => yScale(d.HIGH))
                  .attr("y2", (d) => yScale(d.LOW))

              gY.transition().duration(800).call(d3.axisLeft().scale(yScale));

            }, 500)

            //}
//});
}

      function wrap(text, width) {
            text.each(function() {
              var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
              
              
              while (word = words.pop()) {
                  line.push(word);
                  tspan.text(line.join(" "));
                  if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                  }
              }
        });
        }




      function drawCandleStick(stockData){
                        // a candlestick series, by default it expects the provided data to have open, low, high, close, date properties
              const candlestickSeries = fc.seriesSvgCandlestick()
                .bandwidth(2);

                const xTickFilter = d3.timeDay.filter((d) => d.getDay() === 1);

                // Create the gridlines and series
              const gridlines = fc.annotationSvgGridline();
                //.xTicks(xTickFilter);
              const candlestick = fc.seriesSvgCandlestick();

              // add them to the chart via a multi-series
              const multi = fc.seriesSvgMulti()
                .series([gridlines, candlestick]);
               
                const tradingHours = dates => {
                      const getDateKey = date =>
                        date.getMonth() + "-" + date.getDate() + "-" + date.getFullYear();

                      const tradingHours = dates.reduce((acc, curr) => {
                        const dateKey = getDateKey(curr);
                        if (!acc.hasOwnProperty(dateKey)) {
                          acc[dateKey] = [curr, curr];
                        } else {
                          acc[dateKey][1] = curr;
                        }
                        return acc;
                      }, {});

                      return Object.keys(tradingHours).map(d => tradingHours[d]);
                    };
              // adapt the d3 time scale to add discontinuities, so that weekends are removed
          

                const skipWeekendScale = fc.scaleDiscontinuous(d3.scaleTime())
              .discontinuityProvider(fc.discontinuitySkipWeekends());

              const tradingHoursArray = tradingHours(stockData.map(d => d.date));
              const discontinuities = d3
              .pairs(tradingHoursArray)
              .map(d => [d[0][1], d[1][0]]);

               skipWeekendScale.discontinuityProvider(fc.discontinuityRange(...discontinuities));

              const chart = fc.chartCartesian(
                skipWeekendScale,
                  d3.scaleLinear()
                )
                .yOrient('left')
                .svgPlotArea(multi);

              // use the extent component to determine the x and y domain
              const xExtent = fc.extentDate()
                .accessors([d => d.date]);

              const yExtent = fc.extentLinear()
                .accessors([d => d.HIGH, d => d.LOW]);

              const parseDate = d3.timeParse("%d-%b-%y");
              
                var data =  stockData.map(row => ({
                    open: Number(row.OPEN),
                    close: Number(row.CLOSE),
                    high: Number(row.HIGH),
                    low: Number(row.LOW),
                    date: row.date

                   
                  }));//
                  chart.xDomain(xExtent(data))
                          .yDomain(yExtent(data))

                          // select and render
                          d3.select('#candleChart')
                          .datum(data)
                          .call(chart);


          marketProfileChart(stockData);

                
      }

  }
});
</script>
</head>
<body>
  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>                        
          </button>
        <a class="navbar-brand" href="/index">Scanner</a>
      </div>
      <div class="collapse navbar-collapse" id="myNavbar">
        <ul class="nav navbar-nav">
      

          <!-- <li class="active"><a href="/index">Home</a></li> -->
          <li ><a href="/gainerloser">Top Gainer / Looser</a></li>
          <li><a href="/gapupdown">Gap up/Down</a></li>
          <li><a href="/allCharts">Stocks Charts</a></li>
          <li ><a href="/scanner">Scanner</a></li>
          <li><a href="/strategy">Strategy</a></li>
          <li><a href="/applyStrategy">Apply Strategy</a></li> 
          <!-- <li><a href="/contactus">Contact Us</a></li>   -->
        </ul>
        <ul class="nav navbar-nav pull-right">
          <li class="dropdown pull-right"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Welcome, <span id="userTxt"></span> <span class="glyphicon glyphicon-user"></span><b class="caret"></b></a>
            <ul class="dropdown-menu pull-right">
                <li><a href="/profile"><i class="icon-cog"></i> Profile</a></li>
                <li><a href="/authenticate"><i class="icon-cog"></i> Upstox Login</a></li>
                <li><a href="/preferences"><i class="icon-envelope"></i> Preferences</a></li>
                <li class="divider"></li>
                <li><a href="/logout"><span class="glyphicon glyphicon-off"></span> Logout</a></li>
            </ul>
        </li>
      </ul>
      </div> 
    </div>
  </nav>
          
  <div class="container">
    <div class="row"></div>
    </br>
    </br>
    </br>
    <div class="row">
          <div class="col-sm-2">
            <label>Symbol</label>
            <input type="text" id="symbolTxt" list="symbolDropdown" class="form-control" placeholder="Search symbol" required autofocus>
            <datalist id="symbolDropdown"></datalist>
          </div>
          <div class="col-sm-2">
            <label>Interval</label>
            <select id="intervalDropDown" class="form-control" >
                <option value="5MINUTE">5MINUTE</option>
                <option value="15MINUTE" selected="selected">15MINUTE</option>
                <option value="30MINUTE">30MINUTE</option>
                <option value="60MINUTE">60MINUTE</option>
                <option value="1DAY" >1DAY</option>
                <option value="1WEEK">1WEEK</option>
                <option value="1MONTH">1MONTH</option>
              </select>
          </div>
    </div> 

    <div class="row">
        <span id="symbol_txt" class="col-md-6"></span>
        <span  class="col-md-6"> <span>Time :</span><span id="date_txt"></span></span>
    </div>
    <br/>
 
    <div class="row">
      <div class="col-md-6" style="position: relative; height:100vh; width:90vw;">
          
        <div id='chartDiv' style="position: relative; width:100vw;max-width: 1000px;height:80vh;"> 
         
          <div>
            
        <div id='marketChart' style="position: relative; width:100vw;max-width: 1000px;height:80vh;">
           <!--  <svg id="container" style="position: relative;width:100vw;max-width: 1000px;"></svg> -->
          </div>  
          
                
          </div>
      </div>  
    </div>
  </div>
  <div class="loader"></div>
</body>
</html>